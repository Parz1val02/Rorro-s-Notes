#programming
#### Strings
strcpy(destination, source): This function will copy a string from a source to a destination, iterating through each byte and copying it
#\i\n\c\l\u\d\e <string.h>

_Unsigned variables:_ all positive numbers, prepend the keyword **unsigned** to the declaration
sizeof(): determines the size of a data type

#### Byte size of data types
int -> 4 bytes
unsigned int -> 4 bytes
short int -> 2 bytes
long int -> 4 bytes
long long int -> 8 bytes
float -> 4 bytes
char -> 1 byte

> Short and long keywords also work with floating-point variables

#### Format Strings

%d -> Decimal
%u -> Unsigned decimal
%x -> Hexadecimal
%s -> String
%n -> Number of bytes written so far
%p -> equivalent to 0x%08x

> %s and %n expect to be given a memory address

Field-width: integer that designates the minimum field width for that parameter

#### Typecast
Void pointer: typeless pointer. It's main purpoie is to hold a memory address

#### Command line arguments
Two argmuments needed in the main function:
int argc: the number of arguments
char \*argv[]: array of strings that contains each of those arguments (also known as argument vector)
>Arguments are always passed as strings from the commandline
>atoi(): This function accepts a pointer to a string as its argument and returns the integer value it represents. Also known as **ASCII to integer**

==Segmentation fault:== It happens when the programm attempts to access an address that is out of bounds
Signal for segmentation fault -> SIGSEGV

#### Variable scoping
>Variables are global if they are defined at the beginning of the code, outside any function

GDB
bt -> backtrace, shows the function calls
Each time a function is called, a record called a *stack frame* is put on the stack. Each *stack frame* also contains the local variables for that context
bt full -> shows the local variables contained in each *stack frame*

>Static variables remain intact between function calls and within a particular function context. They are only initialized once

#### File Access
1. File descriptors: Lower level set of I/O functions
	1. Open:
	Access modes: O_RDONLY -> Open file for read-only access
						O_WRONLY -> Open file for write-only access
						O_RDWR -> Open file for both read and write access
	Optional flags: O_APPEND -> Write data at the end of the file
						O_CREAT -> Create the file if it doesn't exist
						O_TRUNC -> If the file already exists, truncate the file to 0 length
	Useful libraries: <fcntl.h> -> contains the access modes
							<sys/stat.h> -> contains the file permissions if O_CREAT is used
	1. Close
	2. Read
	3. Write
	All of these functions return -1 if there is an error
2. File streams: Higher level form of buffered I/O built upon lower level functions

#### User ids
*chsh*: this command allows any user to change their own login shell, it makes changes to /etc/passwd. In order to do that, it needs to acces and edit this file that can only be written to by root. It uses _set user ID_

getuid(): real user ID
geteuid(): effective user id

>When a filename for a \#include is surrounded by <>, the compiler looks for this file in standard include paths, such as /usr/include
>If the filename is surrounded by "", the compiler looks in the current directory

#### Structs
Structs are variables that can contain many other variables
Methods to access struct elements:
struct.variable //Direct access
struct_pointer->variable //Access via pointer

*Function pointers exist pipipi* 